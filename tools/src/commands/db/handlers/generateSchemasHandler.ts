import chalk from 'chalk'

import { isDockerMode } from '@/utils/helpers'
import CLILoggingService from '@/utils/logging'
import getPBInstance from '@/utils/pocketbase'

import { buildModuleCollectionsMap } from '../functions/schema-generation/module-mapper'
import { processSchemaGeneration } from '../functions/schema-generation/schema-processor'

/**
 * Command handler for generating database schemas
 */
export async function generateSchemaHandler(
  targetModule?: string
): Promise<void> {
  try {
    CLILoggingService.info('Starting schema generation process...')

    const { pb, killPB } = await getPBInstance(!isDockerMode())

    CLILoggingService.debug('Fetching collections from PocketBase...')

    const allCollections = await pb.collections.getFullList()

    const userCollections = allCollections.filter(
      collection => !collection.system
    )

    CLILoggingService.info(
      `Found ${userCollections.length} user-defined collections`
    )

    // Build ID-to-name map for all collections (including system)
    // This allows relation fields to reference collections by name instead of ID
    const idToNameMap = new Map<string, string>()

    for (const collection of allCollections) {
      idToNameMap.set(collection.id, collection.name)
    }

    const moduleCollectionsMap =
      await buildModuleCollectionsMap(userCollections)

    const { moduleSchemas } = await processSchemaGeneration(
      moduleCollectionsMap,
      idToNameMap,
      targetModule
    )

    // Note: core/schema.ts is generated by the module registry generator (bun forge modules install)
    // db pull only updates individual module schema files

    const moduleCount = Object.keys(moduleSchemas).length

    CLILoggingService.info(
      targetModule
        ? `Schema generation completed for module ${chalk.bold.blue(targetModule)}!`
        : `Schema generation completed! Created ${moduleCount} module schema files.`
    )

    killPB?.()
  } catch (error) {
    CLILoggingService.error(`Schema generation failed: ${error}`)
    process.exit(1)
  }
}
