import Code from '../../components/Code'
import Note from '../../components/Note'

###### Forms

# Taking Input Gracefully

Rather than relying on third-party form libraries like <code>Formik</code>, <code>React Hook Form</code>, or <code>TanStack Form</code>, LifeForge implements a custom solution tailored to its specific needs. While this approach trades some flexibility for consistency, it delivers a unified and streamlined form handling experience throughout the ecosystem.

<div className="flex-center mt-12 w-full">
  <img
    src="https://raw.githubusercontent.com/Lifeforge-app/lifeforge-docs-media/main/assets/developer-forms/form.webp"
    alt=""
    className="w-full rounded-lg"
  />
</div>

---

<section id="motivation">
  ## Motivation

> Why don't you just use a form library?

Third-party form libraries undeniably offer extensive out-of-the-box functionality that meets industry standards. For most applications requiring form handling, these libraries are the recommended choice. However, they often introduce overhead and complexity that doesn't align with LifeForge's specific requirements, and their opinionated design philosophies sometimes conflict with the project's vision.

This realization came after building LifeForge's form system and subsequently exploring popular React form solutions. While the custom system was already serving its purpose well, I investigated other approaches to gather insights and identify beneficial patterns for potential improvements.

There was a moment when switching to an established form library seemed appealing, but ultimately, the existing implementation proved both effective and well-suited to the project's needs. Introducing additional complexity felt unnecessary.

**Since LifeForge requires forms specifically for its own ecosystem rather than a general-purpose solution, a tailored approach delivers greater value than adopting a generic library.**

</section>

<section id="gist">
    ## Gist
    
    LifeForge's form system centers on defining forms and their fields declaratively through chained methods. This approach consolidates form configuration, validation rules, and submission logic into a single, maintainable location.
    
    Here's how you define a form in LifeForge:
    
    <Code language="tsx">
    {`const { formProps } = defineForm<{
      title: string
      age: number
      color: string
      icon: string
    }>({
      icon: 'tabler:forms',
      title: 'Form Modal',
      namespace: '',
      onClose: () => {},
      loading: false,
      submitButton: {
        icon: 'tabler:check',
        children: 'Submit'
      }
    })
    .typesMap({
      title: 'text',
      age: 'number',
      color: 'color',
      icon: 'icon'
    })
    .setupFields({
      title: {
        label: 'Title',
        icon: 'tabler:text-size',
        placeholder: 'Title Of The Document',
        required: true,
        validator(value) {
          if (!value.match(/^[a-zA-Z0-9 ]+$/)) {
            return 'Invalid title. Only alphanumeric characters and spaces are allowed.'
          }

          return true
        }
      },
      age: {
        icon: 'tabler:number-123',
        label: 'Age',
        validator: value => {
          if (value < 0) {
            return 'Invalid age. Age must be positive.'
          }

          return true
        }
      },
      color: {
        label: 'Color'
      },
      icon: {
        label: 'Icon',
        required: true
      }
    })
    .initialData({})
    .onSubmit(async formData => {
      // Handle form submission logic here
      alert(\`Form submitted with data: \${JSON.stringify(formData)}\`)
      await new Promise(resolve => setTimeout(resolve, 1000))
      alert('Form submitted successfully!')
    })
    .build()`}
    </Code>

    The <code>.typesMap()</code> method's available options depend on each field's TypeScript type. For instance, <code>number</code> fields support both <code>number</code> and <code>currency</code> types.

    Similarly, subsequent method options are constrained by values from previous methods or the form's generic type definition, ensuring type safety throughout the configuration process.

    In the <code>onSubmit</code> method, the <code>formData</code> parameter is guaranteed to be type-safe and aligned with the data structure defined in <code>defineForm</code>. This ensures confidence that submitted data is always valid and correctly formatted.

</section>

<section id="design-philosophy">
  ## Design Philosophy
  
  To quote the [@tanstack/form](https://tanstack.com/form/latest/docs/philosophy) documentation:
  
  > "Every well-established project should have a philosophy that guides its development. Without a core philosophy, development can languish in endless decision-making and have weaker APIs as a result."
  
  Here's the design philosophy behind LifeForge's form system:

### Abstraction over Repetition

Consider the verbose approach required by libraries like <code>@tanstack/form</code>, where each field demands repetitive boilerplate:

<Code language="tsx">
  {`<form.Field
    {...otherProps}
    children={(field) => {
        // Avoid hasty abstractions. Render props are great!
        return (
        <>
            <label htmlFor={field.name}>First Name:</label>
            <input
            id={field.name}
            name={field.name}
            value={field.state.value}
            onBlur={field.handleBlur}
            onChange={(e) => field.handleChange(e.target.value)}
            />
            <FieldInfo field={field} />
        </>
        )
    }}
/>`}
</Code>

The documentation includes this telling comment:

> "Avoid hasty abstractions. Render props are great!"

While this approach works for applications with minimal form requirements, **projects like LifeForge—which are fundamentally built around forms—find this pattern verbose, repetitive, and difficult to maintain at scale.**

The solution: create a declarative system that eliminates repetition while enabling form field reusability across different contexts.

### Absolute Type Safety

Anyone who has worked with data submission understands the frustration of type mismatches between form data and backend expectations. Since LifeForge already maintains a robust API type system (see [here](/backend/api)), the form system leverages this foundation to ensure perfect synchronization between form data and expected structures.

This enables powerful type inference:

<Code language="tsx">
  {`defineForm<InferOutput<typeof forgeAPI.myApp.coolStuff.create>['body']>()`}
</Code>

Subsequent form configuration becomes fully type-safe, as does the final data output. This guarantees that form data always aligns with expected structures, providing confidence in data validity and format.

### Declarative Form Field Definitions

Rather than imperatively defining field behavior step-by-step, LifeForge embraces a declarative approach where you describe **what** the form should accomplish and **how** it should behave, not **how** to construct it.

Compare the traditional imperative approach:

  <Code language="tsx">
{`const [title, setTitle] = useState('')
  const [titleError, setTitleError] = useState('')

const handleTitleChange = (value: string) => {
setTitle(value)
if (!value.match(/^[a-zA-Z0-9 ]+$/)) {
setTitleError('Invalid title. Only alphanumeric characters and spaces are allowed.')
} else {
setTitleError('')
}
}

return (

<form onSubmit={handleSubmit}>...</form>) `}

  </Code>

With LifeForge's declarative approach:

<Code language="tsx">
{`const { formProps } = defineForm<FormData>({
  ...uiConfig
})
  .typesMap({...})
  .setupFields({...})
  .initialData({...})
  .onSubmit({...})
  .build()

return <Form {...formProps} />
`}

  </Code>

This declarative pattern offers significant advantages:

- **Clarity**: Form configuration becomes self-documenting and immediately comprehensible
- **Consistency**: All forms follow identical patterns, enhancing codebase maintainability
- **Reusability**: Field configurations can be extracted and shared across different forms
- **Type Safety**: Complete typing based on your form data structure
- **Reduced Boilerplate**: Eliminates manual state management, validation, and error handling per field
</section>

<section id="building-a-form">
  ## Building A Form

The form system is designed to be intuitive and straightforward. Here's a step-by-step guide to building a form.

### 1. Define Your Form Schema

Start by defining the structure of your form data. It can be a custom typescript interface:

<Code language="typescript">
  {`interface FormData {
    firstName: string;
    lastName: string;
    email: string;
  }
  `}
</Code>

Or a type inferred from ForgeAPI:

<Code language="typescript">
  {`type FormData = InferOutput<typeof forgeAPI.myApp.coolStuff.create>['body']}`}
</Code>

Thanks to the powerful capabilities of TypeScript, even if the type interface is in the form of a complex union like this:

<Code language="typescript">
  {`type FormData = {
    username: string;
    email: string;
    password: string;
  } & ({
    type: 'student';
    course: string;
  } | {
    type: 'teacher';
    subject: string;
  })`}
</Code>

When being parsed by the form system, this complex union type will be flattened into a flat structure that is easier to work with:

<Code language="typescript">
  {`type FormData = {
    username: string;
    email: string;
    password: string;
    type: 'student' | 'teacher';
    course: string;
    subject: string;
  }`}
</Code>

That way, the form system can easily map the flattened structure to the appropriate form fields.

Finally, call the <code>defineForm</code> function with the form data type as a generic parameter:

<Code language="tsx">{`const { formProps } = defineForm<FormData>()`}</Code>

### 2. Create the Form Component

In the LifeForge ecosystem, all forms are presented in the UI as modals, and are handled by a global modal manager (See [here](/frontend/modal-manager) for more details).

Import the <code>defineForm</code> function and the <code>FormModal</code> component from the LifeForge UI library. Then, create a component and call the <code>defineForm</code> function while passing the form data type as a generic parameter. chain it with a <code>.build()</code> call to get the final form props, then pass those props to the <code>FormModal</code> component being returned.

  <Code language="tsx">
  {`import { defineForm, FormModal } from 'lifeforge-ui'

function MyForm({
onClose
}: {
onClose: () => void;
}) {
const { formProps } = defineForm<FormData>({}).build()

    return <FormModal {...formProps} />

}
`}

  </Code>

<Note>
  The <code>FormModal</code> component should be the only thing being returned
  by the modal component.
</Note>

### 3. Configuring the Form

In the argument object being passed into the <code>defineForm</code> function, you can specify various properties such as the form's title, icon, namespace, loading state, and submit button configuration. This allows you to customize the form's appearance and behavior right from the start. Detailed explanation of each property is listed below:

- <div className="text-lg!">
    <code className="text-lg!">icon</code> &{' '}
    <code className="text-lg!">title</code>
  </div>

  These properties define the form's title and the icon displayed in the modal header, as shown in the figure below. The icon must be a valid icon identifier from Iconify in the form of <code>&lt;icon-set&gt;:&lt;icon-name&gt;</code>.

  ![form-header](https://raw.githubusercontent.com/Lifeforge-app/lifeforge-docs-media/main/assets/developer-forms/formHeader.webp)

- <code className="text-lg!">onClose</code>

  This callback function is triggered when the close button is clicked. This should be the same <code>onClose</code> function being passed to the modal component, allowing the form to close itself when the user clicks the close button.

- <code className="text-lg!">submitButton</code>

  Can be either <code>"create"</code>, <code>"update"</code>, or an object containing the button's props if a custom button is needed. If either <code>"create"</code> or <code>"update"</code> is used, a predefined button will be rendered with the appropriate label and icon, as shown below:

  ![form-btn-create](https://raw.githubusercontent.com/Lifeforge-app/lifeforge-docs-media/main/assets/developer-forms/btnCreate.webp)

  ![form-btn-update](https://raw.githubusercontent.com/Lifeforge-app/lifeforge-docs-media/main/assets/developer-forms/btnUpdate.webp)

- <code className="text-lg!">actionButton</code>

  This button is displayed at the top right corner of the modal, next to the close button. It can be used to trigger additional actions related to the form.

  ![form-btn-action](https://raw.githubusercontent.com/Lifeforge-app/lifeforge-docs-media/main/assets/developer-forms/actionBtn.webp)

- <code className="text-lg!">loading</code>

  This boolean property controls the loading state of the form. When set to true, the form will display a loading indicator instead of the form fields. This is useful when the data required by the form (e.g. listbox options) is being fetched asynchronously.

  ![form-loading](https://raw.githubusercontent.com/Lifeforge-app/lifeforge-docs-media/main/assets/developer-forms/formLoading.webp)

- <code className="text-lg!">namespace</code>

  This property defines the i18n namespace for the text and labels used in the form. For more information on i18n namespaces, see the [i18n documentation](/frontend/i18n).

The defineForm function call should now look something like this:

<Code language="tsx">
  {`const { formProps } = defineForm<FormData>({
    title: 'My Form',
    icon: 'mdi:form-textbox',
    onClose: onClose, // Pass the onClose function from the parent component
    submitButton: 'create',
    actionButton: {
      icon: 'mdi:custom-icon',
      variant: 'plain',
      onClick: () => console.log('Custom action clicked')
    },
    namespace: 'apps.myApp'
  }).build()`}
</Code>

### 4. Mapping Field Types

Now, it's time to map the form fields to their corresponding input components. Since there can be multiple options for input component available for each Typescript value type (e.g. <code>NumberInput</code> and <code>CurrencyInput</code>) for a field with type <code>number</code>), you must specify the appropriate input component for each field in the form with the <code>.typesMap()</code> chain method.

Using this method is pretty straightforward, it accepts a mapping object where the keys are the field keys and the values are the corresponding input component types.

  <Note>
  Available input component types can be found in the IntelliSense suggestions.

![types-map-intellisense](https://raw.githubusercontent.com/Lifeforge-app/lifeforge-docs-media/main/assets/developer-forms/typesMapIntellisense.webp)

  </Note>

### 5. Configuring Fields

Using the <code>.setupFields()</code> chain method, you can configure each field's properties such as label, icon, placeholder, validation rules, and more. This allows you to customize the form fields to suit your application's needs.

  <Code language="tsx">
  {`const { formProps } = defineForm<FormData>().setupFields({
    name: {
      label: 'Name',
      icon: 'tabler:user',
      placeholder: 'John Doe',
      required: true,
      validator(value) {
        if (!value.match(/^[a-zA-Z ]+$/)) {
          return 'Invalid name. Only alphabetic characters and spaces are allowed.'
        }

        return true
      }
    },

}).build()`}

  </Code>

  <Note>
  Available field configurations can be found in the IntelliSense suggestions.

![setup-fields-intellisense](https://raw.githubusercontent.com/Lifeforge-app/lifeforge-docs-media/main/assets/developer-forms/setupFields.webp)

  </Note>

### 6. Conditional Fields (optional)

Sometimes you may want to show or hide certain fields in the form based on the values of other fields. This can be achieved using the <code>.conditionalFields()</code> chain method. This method accepts a mapping of field names to a function that returns a boolean indicating whether the field should be shown. The function has one parameter, which is the current form values.

For example, to show the "age" field only if the "isAdult" checkbox is checked, you can do the following:

<Code language="tsx">
  {`const { formProps } = defineForm<FormData>().conditionalFields({
    // Ask for parent's name if not an adult
    parentName: (formState) => !formState.isAdult
  }).build()`}
</Code>

### 7. Define Field to be Autofocused (optional)

Sometimes you will want to automatically focus a specific field when the form is opened. This can be achieved using the <code>.autoFocusField()</code> chain method.

For example, to autofocus the "name" field, you can do the following:

<Code language="tsx">
  {`const { formProps } = defineForm<FormData>().autoFocusField('name').build()`}
</Code>

  <Note>
  The options for this method is determined by your definition in the <code>.typesMap()</code> chain method, and only fields that are auto-focusable will be available. IntelliSense will help you identify these fields.

![auto-focus-field-intellisense](https://raw.githubusercontent.com/Lifeforge-app/lifeforge-docs-media/main/assets/developer-forms/autofocus.webp)

  </Note>

### 8. Populate the Form

Often times you will want to populate the form with existing data, such as when editing an existing record. This can be achieved using the <code>.initialData</code> chain method, which accepts an object that matches the form data type.

<Code language="tsx">
  {`const { formProps } = defineForm<FormData>().initialData({
    name: 'John Doe',
    age: 30,
    color: 'blue',
    icon: 'mdi:account'
  }).build()`}
</Code>

  <Note>
  The data type of the argument of this method is the same as the form data type generic parameter, with all fields being optional. IntelliSense is available to help you construct the initial data object. Feel free to pass in the entire data record being passed into the parent component if it has the fields that the form requires, or you can make some slight modifications to it to match the form data type.

  <Code language="tsx">
  {`
  export default function MyFormModal({
    onClose,
    data: {
      initialData
    }
  }: {
    onClose: () => void,
    data: {
      initialData: Partial<FormData>
    }
  }) {
    const { formProps } = defineForm<FormData>({...}).initialData({
      ...initialData,
      location: {
        name: initialData?.location_name || ',
        location: {
          longitude: initialData?.location?.lon || 0,
          latitude: initialData?.location?.lat || 0
        },
        formattedAddress: initialData?.location_name || ''
      }
    }).build()

    return <FormModal {...formProps} />

}
`}

  </Code>
  </Note>

### 9. Submitting the Form

Finally, you can define the form submission logic using the <code>.onSubmit()</code> chain method. This method accepts an asynchronous function that receives the form data as its argument. You can perform any necessary actions with the data, such as sending it to ForgeAPI or processing it locally.

<Code language="tsx">
  {`const { formProps } = defineForm<FormData>().onSubmit(async (data) => {
    await forgeAPI.myApp.coolStuff.create.mutate(data)
  }).build()`}
</Code>

It's highly recommended to handle form submission using mutation hook from React Query.

  <Code language="tsx">
  {`const mutation = useMutation(
    (openType === "create"
      ? forgeAPI.myApp.coolStuff.create
      : forgeAPI.myApp.coolStuff.update.input({ id: initialData?.id || '' })
    ).mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ['myApp.coolStuff'] })
      },
      onError: (error) => {
        toast.error('Failed to submit form:', error)
      }
    })
  )

const { formProps } = defineForm<FormData>().onSubmit(async (data) => {
await mutation.mutateAsync(data)
}).build()`}

  </Code>

</section>

<section id="field-validation">
  ## Field Validation

In LifeForge, validation is done only before the form is submitted.

When defining configurations for each field, you can specify validation rules using the <code>validator</code> property. This property can be a function that returns either <code>true</code> if the value is valid or a string containing an error message if the value is invalid, like so:

<Code language="tsx">
  {`const { formProps } = defineForm<FormData>().setupFields({
    age: {
      ...,
      validator: (value) => {
        if (!value) {
          return 'Age is required'
        }
        if (isNaN(value)) {
          return 'Age must be a number'
        }
        if (value < 0) {
          return 'Age must be a positive number'
        }
        return true
      }
    }
  })`}
</Code>

Alternatively, you can use a Zod schema to define the validation rules for the field. This allows you to leverage Zod's powerful validation capabilities, such as chaining multiple validation methods together.

  <Code language="tsx">
  {`const { formProps } = defineForm<FormData>().setupFields({
    age: {
      ...,
      validator: z
        .number()
        .int('Invalid age. Age must be an integer.')
        .nonnegative('Invalid age. Age must be positive.')
    }
  })`}
  </Code>
</section>

<section id="controlling-form-state-explicitly">
  ## Controlling Form State Explicitly

In some cases, you may find yourself needing to explicitly manage the form state. This can be useful if you need fine-grained control over the form values or if you're working with complex form logic, for example populating a field with AI generated content.

LifeForge uses <code>zustand</code> for form state management. The <code>defineForm</code> function exposes a <code>formStateStore</code> object which is a Zustand store that you can use to get and set the form values.

  <Code language="tsx">
  {`
  export default function ExplicitFormStateExample() {
    const { formProps, formStateStore } = defineForm<FormData>().setupFields({
      name: {
        ...,
        actionButtonProps: {
          ...,
          onClick: () => {
            const { name } = formStateStore.getState()

            const newName = await forgeAPI.myApp.coolStuff.generateCoolerName.mutate({
              currentName: name
            })

            formStateStore.setState(() => ({
              name: newName
            }))
          }
        }
      }
    }).build()

    return <FormModal {...formProps} />

}
`}

  </Code>
</section>

<section id="linked-fields">
  ## Linked Fields

Sometimes you may want to link two or more fields together, such as when one field's value depends on another field's value. This can be achieved easily using the <code>formStateStore</code>.

For example, the validation of the <code>confirmPassword</code> field could depend on the value of the <code>password</code> field.

  <Code language="tsx">
  {`export default function LinkedFieldsExampleModal() {
    const { formProps, formStateStore } = defineForm<FormData>()
      .setupFields({
        password: {
          ...
        },
        confirmPassword: {
          ...
          validator: (value) => {
            if (value !== formStateStore.getState().password) {
              return 'Passwords do not match'
            }
            return true
          }
        }
      })
      .build()

    return <FormModal {...formProps} />

}
`}

  </Code>
</section>

<section id="derived-listbox-options">
  ## Derived Listbox Options

You can derive the options for a listbox field based on the values of other fields in the form. This is useful for creating dynamic forms where the available options depend on user input.

When configuring the options for a listbox field, you can use a function that accesses the current form state to determine the available options. This function will grant you access to the current form state and allow you to compute the options dynamically.

  <Code language="tsx">
  {`export default function DerivedListboxExampleModal() {
    const { formProps } = defineForm<FormData>()
      .setupFields({
        category: {
          ...,
          options: [
            { value: 'fruits', label: 'Fruits' },
            { value: 'vegetables', label: 'Vegetables' }
          ]
        },
        item: {
          ...,
          options: (formState) => {
            const category = formState.category
            if (category === 'fruits') {
              return [
                { value: 'apple', label: 'Apple' },
                { value: 'banana', label: 'Banana' }
              ]
            }
            if (category === 'vegetables') {
              return [
                { value: 'carrot', label: 'Carrot' },
                { value: 'broccoli', label: 'Broccoli' }
              ]
            }
            return []
          }
        }
      })
      .build()

    return <FormModal {...formProps} />

}
`}

  </Code>
</section>
