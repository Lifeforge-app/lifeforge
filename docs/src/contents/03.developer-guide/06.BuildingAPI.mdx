import { Alert } from "lifeforge-ui"

###### Building API

# Type-safe Heaven Inspired by tRPC

LifeForge's API is built using a custom-built type-safe framework inspired by [tRPC](https://trpc.io/). All the types are inferred from one step to another with barely any explicit declarations, ensuring that the data structures remain consistent throughout the controllers, services, and database layers.

---

<section id="motivation">
## Motivation

At the very beginning of LifeForge's development, I was using RESTful APIs with Express.js like many other small-scale projects. However, as the project grew, I found myself constantly battling with type mismatches and data inconsistencies between the frontend and backend. This led to a lot of runtime errors that could have been avoided with better type safety.

At quite some points in time, I asked ChatGPT to come up with solutions to these problems, and it once suggested using tRPC, if I remember correctly, but I didn't pay much attention to it. Later on, I stumbled upon tRPC yet again in a video made by [Theo - t3.gg](https://www.youtube.com/@t3dotgg) stating that tRPC is the only right way to build an API. Intrigued, I decided to give it a try. However, I found that tRPC, while powerful, isn't quite flexible enough for seamless integration with the current architecture of LifeForge.

With a click of a button, everything was rolled back to the previous commit, and so was the idea of using tRPC. With that said, I was still stunned by the idea of type-safe APIs and decided to build my own framework on top of the existing architecture of LifeForge. This way, I could ensure that the API layer is tightly integrated with the rest of the application while still benefiting from type safety.

So yeah, after dozens of hours of developer rage and a tremendous conversation thread with ChatGPT, I finally came up with a solution that works for LifeForge. A lot of the codes are written by AI, not gonna lie, and I was absolutely perplexed by the fancy TypeScript inference magic. But don't worry, **I have a pretty good understanding of how everything works now**. =)

So yeah, lots of improvements can be made and have been made since then, and it will only get better. Nonetheless, I am pretty satisfied with the current state of the API layer in LifeForge. It is a type-safe, flexible, and easy-to-use masterpiece that has significantly improved the development experience and reduced runtime errors.

Shown below is a comparison between the old and new ways of building APIs in LifeForge.

![](https://raw.githubusercontent.com/LifeForge-app/lifeforge-docs-media/main/assets/developer-building-api/comparison.webp)

<Alert className="mt-6" type="note">
  #### It's a Mixture of RESTful APIs and tRPC

  Unlike ordinary RESTful APIs where there are multiple HTTP methods (GET, POST, PUT, DELETE, etc.), LifeForge's API is built around two core concepts: **queries** and **mutations**, which corresponds to read and write operations, respectively. This is similar to the approach taken by GraphQL and tRPC. Therefore, only two HTTP methods are used: `GET` for queries and `POST` for mutations.

  For queries, the business logic should be idempotent and should not modify any data. They are meant for retrieving data from the server. On the other hand, mutations are meant for creating, updating, or deleting data on the server. They can have side effects and are not idempotent.
</Alert>

</section>

<section id="quick-start">
## Quick Start

### 1. Create Schema & Forge Factory

Schemas are defined in the **PocketBase dashboard** and pulled to your codebase using `bun forge db pull`. This auto-generates `server/schema.ts` with Zod types for your collections. Then create a Forge factory by importing your schema and passing it to `createForge` – this gives you type-safe `query()` and `mutation()` builders.

```typescript
// server/forge.ts
import { createForge } from '@lifeforge/server-utils'
import schema from './schema'  // Auto-generated by: bun forge db pull

export default createForge(schema)
```

<Alert className="mt-6" type="note">
  The schema only provides type-safe access to your **module's own collections**. To access collections from other modules or core, bypass the type-safe wrapper using `pb.instance.collection('collection_name')` directly.
</Alert>

### 2. Define Routes

Use your forge factory to build handlers with method chaining. Start with `.query()` for GET requests or `.mutation()` for POST. Chain `.input()` for validation through Zod, then `.callback()` for your logic. The `pb` object provides a fluent API for database operations.

```typescript
// server/routes/items.ts
import z from 'zod'
import forge from '../forge'

export const list = forge.query().input({}).callback(({ pb }) =>
  pb.getFullList.collection('items').execute()
)

export const create = forge.mutation()
  .input({ body: z.object({ name: z.string() }) })
  .statusCode(201)
  .callback(({ pb, body }) => pb.create.collection('items').data(body).execute())
```

### 3. Export Router

Group your route handlers using `forgeRouter` and export them. The server automatically loads `server/index.ts` from each module and registers the routes under the module's namespace (e.g., `/my-module/items/list`).

```typescript
// server/index.ts
import { forgeRouter } from '@lifeforge/server-utils'

import * as itemsRouter from './routes/items'
// Other routes import...

export default forgeRouter({ 
  items: itemsRouter,
  // Other routes goes here...
})
```

### 4. Call from Frontend

First, create a type export for your routes and set up the API client:

```typescript
// server/routes.types.ts
import type routes from '.'
export type APIRoutes = typeof routes

// client/src/utils/forgeAPI.ts
import { type APIRoutes } from '@server/routes.types'
import { createForgeProxy } from 'shared'

const forgeAPI = createForgeProxy<APIRoutes>(
  import.meta.env.VITE_API_HOST,
  'yourModuleName'  // in camelCase
)
export default forgeAPI
```

Then use `forgeAPI` with React Query for fully typed API calls:

```typescript
import forgeAPI from '@/utils/forgeAPI'
const { data } = useQuery(forgeAPI.items.list.queryOptions())
```

For client-side details, see [Using API](/developer-guide/using-api).

</section>

<section id="the-forge-factory">
## The Forge Factory

The Forge factory is the heart of LifeForge's API system. It's a preconfigured builder that knows about your module's database collections and provides type-safe methods for creating route handlers.

### Creating the Factory

Each module creates its own forge factory in `server/forge.ts`:

```typescript
// server/forge.ts
import { createForge } from '@lifeforge/server-utils'
import schema from './schema'  // Auto-generated by: bun forge db pull

export default createForge(schema)
```

The `createForge` function takes your schema and returns a factory with two methods:

| Method | HTTP | Purpose |
|--------|------|--------|
| `forge.query()` | GET | Read-only operations that don't modify data |
| `forge.mutation()` | POST | Write operations that create, update, or delete data |

### What the Schema Enables

When you pass a schema to `createForge`, you get:

1. **Type-safe collection names** – The `pb.*.collection()` method only accepts collection names defined in your schema.
2. **Automatic existence checks** – The `.existenceCheck()` that validates records exist before running your callback is also type-safe.
3. **Inferred field types** – All `pb` operations are type-safe end-to-end. The return type of database queries and mutations is automatically inferred from your schema, so filtering, sorting, expanding relations, and the final result all have proper types.

### The Builder Pattern

Both `forge.query()` and `forge.mutation()` return a builder that supports method chaining:

```typescript
forge.query()
  .description('Human-readable description')   // API documentation
  .input({ query: z.object({...}) })           // Zod validation
  .existenceCheck('query', { id: 'items' })    // Auto-validate record exists
  .callback(({ pb, query }) => ...)            // Your business logic
```

Each method returns a new builder instance, so the order of chaining doesn't matter (except `.callback()` should be last).

</section>

<section id="routing">
## Routing

Routing in LifeForge's API is handled using `forgeRouter`. Route handlers are grouped together and exported as a module. This module is then loaded automatically by the server based on the module's `server/index.ts`.

When there are multiple routers, they can be nested within each other to create a hierarchical structure. For example, a wallet module with accounts and transactions:

```plaintext
server/
├── forge.ts
├── schema.ts
├── index.ts
└── routes/
    ├── accounts.ts
    └── transactions.ts
```

In `accounts.ts`, define the API handlers using the module's forge factory:

```typescript
// server/routes/accounts.ts
import z from 'zod'
import forge from '../forge'

export const list = forge
  .query()
  .description('List all accounts')
  .input({})
  .callback(({ pb }) =>
    pb.getFullList.collection('accounts').execute()
  )

export const create = forge
  .mutation()
  .description('Create a new account')
  .input({
    body: z.object({
      name: z.string(),
      balance: z.number().min(0)
    })
  })
  .statusCode(201)
  .callback(({ pb, body }) =>
    pb.create.collection('accounts').data(body).execute()
  )

export const update = forge
  .mutation()
  .description('Update an account')
  .input({
    query: z.object({ id: z.string() }),
    body: z.object({
      name: z.string().optional(),
      balance: z.number().optional()
    })
  })
  .existenceCheck('query', { id: 'accounts' })
  .callback(({ pb, query: { id }, body }) =>
    pb.update.collection('accounts').id(id).data(body).execute()
  )

export const remove = forge
  .mutation()
  .description('Delete an account')
  .input({
    query: z.object({ id: z.string() })
  })
  .existenceCheck('query', { id: 'accounts' })
  .statusCode(204)
  .callback(({ pb, query: { id } }) =>
    pb.delete.collection('accounts').id(id).execute()
  )
```

Then, in `index.ts`, group the routers together:

```typescript
// server/index.ts
import { forgeRouter } from '@lifeforge/server-utils'

import * as accountsRouter from './routes/accounts'
import * as transactionsRouter from './routes/transactions'

export default forgeRouter({
  accounts: accountsRouter,
  transactions: transactionsRouter
})
```

This creates routes like:
- `GET /wallet/accounts/list`
- `POST /wallet/accounts/create`
- `POST /wallet/accounts/update?id=abc123`
- `POST /wallet/accounts/remove?id=abc123`

### Exporting Types for Client

To enable type-safe API calls from the client without bundling server code, create a type export file:

```typescript
// server/routes.types.ts
import type routes from '.'

export type APIRoutes = typeof routes
```

The client can then import `APIRoutes` using `import type` to get full type safety. See [Using API](/developer-guide/using-api) for client integration details.

</section>

<section id="data-input">
## Data Input

LifeForge's approach to taking data input is slightly different from tRPC, where there is only one channel for all the parameters. In LifeForge, the input is divided into two parts: `query` and `body`. Queries are basically the URL search parameters, the part after the `?` in the URL, while body is the request body, which is usually in JSON format or form data. For those who are familiar with RESTful APIs, these should be familiar concepts.

The division of input into query and body is based on the HTTP method used. For `GET` requests, only query parameters are accepted, while for `POST` requests, both query and body parameters are accepted. This design choice is made to adhere to the semantics of HTTP methods, where `GET` requests are meant for retrieving data and should not have a request body, while `POST` requests are meant for creating or updating data and can have a request body.

<Alert className="mt-6" type="note">
  LifeForge's API system does not utilize the URL params feature provided by
  Express.js. This is because URL params are not type-safe and can lead to a lot
  of issues. Instead, all the parameters are passed as query or body, depending
  on the HTTP method.
</Alert>

The input schema is defined in the `.input()` method using [Zod](https://zod.dev/) schemas that follows the handler type definition, as shown below:

```typescript
const myQueryHandler = forge
  .query()
  .input({
    query: z.object({
      name: z.string()
    })
  })

const myMutationHandler = forge
  .mutation()
  .input({
    query: z.object({
      id: z.string().uuid()
    }),
    body: z.object({
      name: z.string(),
      age: z.number().min(0)
    })
  })
```

<Alert className="mt-6" type="warning">
  The value of the `query` and `body` properties in the{' '}
  `.input()` method must be Zod schemas, not plain objects.
</Alert>

These input schemas are then used to validate the incoming requests. If the request does not conform to the schema, a `400 Bad Request` error is returned with a detailed error message. Therefore, you may chain the schema properties with whatever Zod methods you want, such as `.optional()`, `.default()`, `.min()`, `.max()`, etc.

</section>

<section id="media-uploads">
## Media Uploads

More often than not, you would want to upload files to the server, such as images, videos, documents, etc. LifeForge's API system has built-in support for handling file uploads using [Multer](https://github.com/expressjs/multer).

To enable file uploads, you need to use the `.media()` method in the API handler definition. This method takes an object that defines the file fields and their respective configurations. The structure of this object is as follows:

```typescript
type MediaConfig = Record<
  string,
  {
    optional: boolean
    multiple?: boolean
  }
>
```

where the key is the name of the file field, and the value is an object that defines whether the field is optional and whether it accepts multiple files. The media can then be accessed in the `.callback()` method via the `media` property.

LifeForge's API system accepts either valid files or URL strings that point to a valid media resource. If a URL string is provided, the server will automatically download the file and store it in the appropriate location. This is particularly useful when you want to allow users to upload files from external sources without having to download and re-upload them manually, or when being used in conjunction with the `FileInput` component in the frontend, which supports multiple sources such as local files, URLs, Pixabay, AI-generated images, etc.

Most of the time, you would want to store the uploaded files in the database. However, in the scenario where the data record is being updated, the existing files might either be kept, removed, or replaced with new files. To handle this, you can send the string literal `"keep"` to indicate that the existing file should be kept, or `"removed"` to clear the field.
The `core.media.retrieveMedia` utility (available in the callback context) handles all these cases automatically:

| Input | Behavior |
|-------|----------|
| `'keep'` | Returns empty object (no update to field) |
| `'removed'` | Returns `{ [fieldName]: null }` to clear the field |
| URL string | Fetches the URL and converts to `File` |
| Multer file | Reads and converts to `File` |
| `undefined` | Returns `{ [fieldName]: null }` |

```typescript
const update = forge
  .mutation()
  .description("Upload a file")
  .input({
    query: z.object({ id: z.string().uuid() }),
    body: z.object({ name: z.string() })
  })
  .media({
    file: { optional: true }
  })
  .callback(async ({ media: { file }, query: { id }, body, pb, core }) => {
    return pb.update
      .collection('items')
      .id(id)
      .data({
        ...body,
        ...(await core.media.retrieveMedia('file', file))
      })
      .execute()
  })
```
</section>

<section id="validate-record-existence">
## Validate Record Existence

In scenarios where you need to ensure that a record exists in the database before proceeding with the business logic, you can use the `.existenceCheck()` method. This method takes two arguments: the data input source to be checked (either `"query"` or `"body"`), and an object with key being the field name and value being the collection name. If the field is optional, you can wrap the field name in square brackets, e.g. `"[userId]"`.

```typescript
const getUserProfile = forge
  .query()
  .description("Get user profile")
  .input({
    query: z.object({
      userId: z.string().uuid()
    })
  })
  .existenceCheck("query", { userId: "users" })
  .callback(async ({ query: { userId }, pb }) => {
    const user = await pb.collection('users').getOne(userId);
    return user;
  });
```

When the `.existenceCheck()` method is used, the API handler will automatically check if the record exists in the database based on the provided field and collection. If the record does not exist, a `404 Not Found` error is returned with a detailed error message. Otherwise, the business logic in the `.callback()` method will be executed as normal.

</section>

<section id="callback">
## Callback

The core logic of the API handler is defined in the `.callback()` method. This method takes a single argument, which is an async function that contains the business logic of the handler. The argument of this function is an object that contains the validated input data, as well as some additional context information. The structure of this object is as follows:

- `query`: An object containing the validated query parameters.
- `body`: An object containing the validated body parameters (for
  mutations).
- `media`: An object containing the uploaded files (if any).
- `pb`: The PocketBase service instance, which can be used to
  interact with the database. See [Database
  Operations](/developer-guide/database-operations) for more information.
- `io`: The Socket.IO server instance, which can be used to emit
  events to connected clients. See [Real-time
  Features](/developer-guide/real-time-features) for more information.
- `core`: Utility context with logging, AI, file operations, and more (see [Core Context](#core-context)).
- `req, res`: The original Express.js request and response objects,
  which can be used for advanced use cases.

If you have defined the input schema using the `.input()` method, the `query` and `body` properties will be automatically typed based on the schema. This ensures that you have type safety throughout the entire request handling process. Same can be said for the `media` property if you have defined the media fields using the `.media()` method.

Here is an example of a complete API handler that demonstrates the usage of the `.callback()` method:

```typescript
const createUser = forge
  .mutation()
  .description("Create a new user")
  .input({
    body: z.object({
      name: z.string(),
      email: z.string().email()
    })
  })
  .media({
    avatar: { optional: true }
  })
  .callback(async ({ body: { name, email }, media: { avatar }, pb, core }) => {
    const newUser = await pb.create
      .collection('users')
      .data({
        name,
        email,
        ...(await core.media.retrieveMedia('avatar', avatar))
      })
      .execute()

    return newUser
  })
```

### Multiple File Uploads

To accept multiple files for a single field, set `multiple: true` in the media configuration:

```typescript
const createWithAttachments = forge
  .mutation()
  .description("Create item with multiple attachments")
  .input({
    body: z.object({
      name: z.string()
    })
  })
  .media({
    cover: { optional: true },
    attachments: { optional: true, multiple: true }
  })
  .callback(async ({ body, media, pb, core }) => {
    return pb.create
      .collection('items')
      .data({
        ...body,
        ...(await core.media.retrieveMedia('cover', media.cover)),
        ...(await core.media.retrieveMedia('attachments', media.attachments))
      })
      .execute()
  })
```
</section>

<section id="error-handling">
## Error Handling

Errors thrown inside the `.callback()` function are automatically caught and handled by the Forge Controller. You don't need to wrap your code in try-catch blocks for most cases.

### Default Behavior

If you throw a standard JavaScript `Error`, the API will return a `500 Internal Server Error`:

```typescript
const myHandler = forge
  .query()
  .callback(async () => {
    throw new Error("Something went wrong")
    // Returns: 500 Internal Server Error
    // Response: { state: "error", message: "Internal server error" }
  })
```

### ClientError for Controlled Errors

For client-side errors (bad requests, not found, unauthorized, etc.), use the `ClientError` class:

```typescript
import { ClientError } from '@lifeforge/server-utils'

const getItem = forge
  .query()
  .input({
    query: z.object({ id: z.string() })
  })
  .callback(async ({ pb, query }) => {
    const item = await pb.getOne.collection('items').id(query.id).execute()
    
    if (!item) {
      throw new ClientError("Item not found", 404)
    }
    
    if (item.isPrivate) {
      throw new ClientError("You don't have permission to view this item", 403)
    }
    
    return item
  })
```

### ClientError Signature

```typescript
class ClientError extends Error {
  constructor(message: string, code: number = 400)
}
```

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `message` | `string` | (required) | Error message returned to the client |
| `code` | `number` | `400` | HTTP status code |

### Common Status Codes

| Code | Name | Use Case |
|------|------|----------|
| `400` | Bad Request | Invalid input that passed Zod validation |
| `401` | Unauthorized | Authentication required |
| `403` | Forbidden | Insufficient permissions |
| `404` | Not Found | Resource doesn't exist |
| `409` | Conflict | Duplicate resource or state conflict |
| `422` | Unprocessable Entity | Business logic validation failure |

<Alert className="mt-6" type="tip">
  Use `ClientError` for all expected error conditions that the client should handle. Reserve standard `Error` throws for truly unexpected situations (bugs, external service failures, etc.).
</Alert>

</section>

<section id="miscellaneous-methods">
## Miscellaneous Methods

In addition to the core methods mentioned above, there are some other useful methods that can be chained to enhance the functionality of the API handler:

- `.description()`: This method is used to provide a brief
  description of the API handler. This description is used in the auto-generated
  API documentation and can be helpful for understanding the purpose of the
  handler:
  ```typescript
  .description("Get all items")
  ```

- `.noAuth()`: By default, all API handlers require authentication.
  This method can be used to disable authentication for public endpoints, such
  as login and registration.

- `.noEncryption()`: By default, all API handlers use RSA + AES hybrid
  encryption. This method disables encryption for endpoints that return public
  information, binary data, or need maximum performance for non-sensitive data.

- `.statusCode()`: This method is used to set the HTTP status code
  for the response. By default, all handlers return a `200 OK` status
  code. However, you can use this method to set a different status code, such as
  `201 Created` for successful creation of resources or
  `204 No Content` for successful deletion of resources.

- `.middlewares()`: This method is used to add custom Express.js
  middleware functions to the API handler. This can be useful for adding
  additional validation, logging, or other functionality that is not covered by
  the built-in methods.

- `.noDefaultResponse()`: By default, all API handlers return a JSON
  response with a `status` and `data` property. This
  method can be used to disable the default response format and return a custom
  response instead. This is useful for scenarios where you want to return a
  different content type, such as HTML or plain text.

- `.isDownloadable()`: This method is used to indicate that the response is a downloadable file. When this method is used, the corresponding headers will be set automatically, and the response will be treated as a file that can be downloaded by the client.
</section>

<section id="core-context">
## Core Context

The `core` property in the callback context provides access to various utilities:

### Logging

```typescript
core.logging.info('Processing request')
core.logging.error('Something went wrong')
core.logging.debug('Debug info')
```

### External API Integration

```typescript
// Get API key from vault (requires APIKeyAccess declaration in package.json)
const apiKey = await core.api.getAPIKey('openai')

// Structured AI output with Zod schema
const result = await core.api.fetchAI({
  pb,
  provider: 'openai',
  model: 'gpt-4o',
  messages: [{ role: 'user', content: 'Analyze this data' }],
  structure: z.object({ sentiment: z.string(), score: z.number() })
})

// Search locations (Google Maps)
const locations = await core.api.searchLocations(apiKey, 'coffee shops')
```

For detailed API key management documentation, see [API Keys](/developer-guide/api-keys).

### Temporary Files

```typescript
// Read/write JSON files
const data = new core.tempFile('my_data.json').read<MyType>()
new core.tempFile('my_data.json').write(JSON.stringify(data))
```

### Validation

```typescript
// Check if a record exists
const exists = await core.validation.checkRecordExistence(pb, 'users', userId)

// Check if modules are available
const available = await core.validation.checkModulesAvailability('lifeforge--calendar')

// Validate OTP
const valid = await core.validation.validateOTP(pb, { otp, otpId })
```

### Media Utilities

```typescript
// Process uploaded media (handles File, URL string, or 'keep'/'remove')
const mediaData = await core.media.retrieveMedia('avatar', media.avatar)

// Convert PDF to image
const image = await core.media.convertPDFToImage(pdfPath)

// Extract text from image using OCR
const text = await core.media.parseOCR(imagePath)
```

### Task Pool

```typescript
// Add a background task
const taskId = core.tasks.add(io, {
  module: 'my-module',
  description: 'Processing data',
  status: 'running',
  progress: 0
})

// Update task progress
core.tasks.update(io, taskId, { progress: 50 })
core.tasks.update(io, taskId, { status: 'completed', progress: 100 })
```

### Encryption

```typescript
// Encrypt/decrypt data
const encrypted = core.crypto.encrypt(data, key)
const decrypted = core.crypto.decrypt(encrypted, key)

// String variants
const encryptedStr = core.crypto.encrypt2(textData, key)
const decryptedStr = core.crypto.decrypt2(encryptedStr, key)
```
</section>
