import { Icon } from '@iconify/react'

import CustomLink from '../../components/CustomLink'
import { Alert } from "lifeforge-ui"

###### Modules

# With Absolute Modularity in Mind

LifeForge is your canvas, and modules are the vibrant colors that bring your creations to life. With LifeForge's modular architecture and your creativity, the possibilities are endless. Being a developer means you can craft your own modules to extend LifeForge's capabilities. Whether you're looking to add new features, integrate with other tools, or customize the user experience, LifeForge's modular design makes it easy to do so.

---

<section id="module-structure">
## Module Structure

All modules in LifeForge are located in the `apps/` directory at the root of the repository. Each module is contained within its own subdirectory, following a consistent structure to ensure ease of development and maintenance.

### Directory Overview

```plaintext
apps/<author>--<module-name>/
├── manifest.ts          # Client-side configuration & routes
├── manifest.d.ts        # TypeScript declarations for manifest
├── package.json         # Module metadata, dependencies & exports
├── tsconfig.json        # TypeScript config (extends client)
├── .git/                # Independent Git repository
├── client/              # Frontend code (React + Tailwind)
│   ├── pages/           # Page components
│   ├── components/      # Reusable UI components
│   ├── providers/       # Context providers (optional)
│   ├── hooks/           # Custom hooks (optional)
│   ├── utils/           # Utilities (optional)
│   ├── index.tsx        # Main entry point
│   ├── tsconfig.json    # Client TypeScript config
│   └── vite-env.d.ts    # Vite environment types
├── server/              # Backend code (Express)
│   ├── index.ts         # Main router export
│   ├── schema.ts        # Database schema (optional)
│   ├── routes/          # Route handlers
│   ├── utils/           # Server utilities (optional)
│   └── tsconfig.json    # Server TypeScript config
└── locales/             # Translations
    ├── en.json
    ├── ms.json
    ├── zh-CN.json
    └── zh-TW.json
```

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:typescript" /><code className="text-xl!">manifest.ts</code></div>

This file is the entry point for the module and contains the module's metadata and configuration. It defines the module's routes and other settings that are used by the LifeForge runtime to properly integrate the module.

<CustomLink text="Learn More" to="#client-manifest" />

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:typescript" /><code className="text-xl!">tsconfig.json</code></div>

The root `tsconfig.json` configures TypeScript for the manifest file. It extends the client's configuration and provides path aliases:

```json
{
  "extends": "../../client/tsconfig.json",
  "compilerOptions": {
    "paths": {
      "@": ["./client/index"],
      "@/*": ["./client/*"]
    }
  },
  "include": ["manifest.ts"]
}
```

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:folder-client" /><code className="text-xl!">client/</code></div>

This directory contains the frontend code for the module. It is built using React and Tailwind CSS, the same technologies used in the main LifeForge client codebase. Here, you can define the pages, components, and styles specific to your module. A UI library called `lifeforge-ui` is provided in the `packages/` directory to maintain a consistent design language.

The client's `tsconfig.json` provides helpful path aliases:

```json
{
  "compilerOptions": {
    "paths": {
      "@": ["./index"],
      "@/*": ["./*"],
      "@server/*": ["../../../server/src/*"]
    }
  }
}
```

<CustomLink text="Explore UI Library" to="https://ui.lifeforge.dev" />

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:folder-server" /><code className="text-xl!">server/</code></div>

This directory contains the backend code for the module. It is built using ExpressJS, the same framework used in the main LifeForge server codebase. Here, you can define API routes, business logic, and database interactions specific to your module. The powerful `forgeController` and `forgeRouter` utilities provide type-safe API construction with automatic validation, error handling, and response formatting.

<CustomLink text="Learn More" to="#server-integration" />

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:folder-i18n" /><code className="text-xl!">locales/</code></div>

This directory contains the localization files for the module. LifeForge features a **dynamic localization engine** powered by i18next with:

- **Dynamic Loading** – Translations are fetched on-demand via HTTP backend, reducing initial bundle size
- **Namespace Architecture** – Modular organization with `apps.<moduleName>` namespace for your module
- **Dynamic Language Packs** – Users can install any language supported by LifeForge
- **Missing Key Reporting** – Automatic server-side logging for debugging

Create a JSON file for each language you want to support, named with the language code (e.g., `en.json`, `ja.json`, `de.json`). Your module's translations will be automatically loaded when users have the corresponding language pack installed.

<Alert className="mt-6" type="tip">
  LifeForge supports dynamic language pack installation. You should provide translations for at least the languages that come bundled with LifeForge (English, Bahasa Malaysia, Simplified Chinese, Traditional Chinese), but you can add support for any language.
</Alert>

<CustomLink text="Learn More" to="/developer-guide/localization" />

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:nodejs" /><code className="text-xl!">package.json</code></div>

This file contains the module's metadata and dependencies. LifeForge's monorepo is managed using **bun**, which supports workspaces natively. The newest version of **bun** is mandatory since the dependencies management relies on features that are only available in the latest versions.

<CustomLink text="Learn More" to="#package-json-configuration" />

<Alert className="mt-6" type="note">
In bun version 1.2.x and below, workspace dependencies are shared across all workspaces. Starting from bun version 1.3.x, workspace dependencies are isolated, allowing each workspace to have its own set of dependencies without conflicts. This change is crucial for maintaining module independence.
</Alert>
 
</section>

<section id="creating-modules">
## Creating Modules

<Alert className="mt-6" type="warning">
  The `ForgeCLI` module creation wizard is currently a **work in progress**. The interactive prompts for module scaffolding are not yet functional. For now, you'll need to create modules manually by following the structure outlined in this guide.
</Alert>

### Manual Module Creation

Until the CLI wizard is complete, follow these steps to create a new module:

**Step 1:** Create a new directory in `apps/` with the naming convention `<your-username>--<module-name>`:

```bash
mkdir apps/myusername--my-module
cd apps/myusername--my-module
```

**Step 2:** Create the `package.json` file with your module metadata:

```json
{
  "name": "@lifeforge/myusername--my-module",
  "displayName": "My Module",
  "version": "0.0.1",
  "author": "Your Name <your@email.com>",
  "description": "Description of what your module does",
  "scripts": {
    "types": "cd client && bun tsc"
  },
  "dependencies": {
    "@iconify/react": "^6.0.2",
    "@tanstack/react-query": "^5.90.11",
    "lifeforge-ui": "workspace:*",
    "react": "^19.2.0",
    "react-i18next": "^15.1.1",
    "shared": "workspace:*",
    "zod": "^4.1.12"
  },
  "exports": {
    "./manifest": {
      "types": "./manifest.d.ts",
      "default": "./manifest.ts"
    }
  },
  "lifeforge": {
    "icon": "tabler:cube",
    "category": "Utilities"
  }
}
```

**Step 3:** Create the directory structure:

```bash
mkdir -p client server locales
```

**Step 4:** Create the required files (manifest.ts, client/index.tsx, etc.)

**Step 5:** Install dependencies:

```bash
bun install
```

**Step 6:** Initialize a Git repository:

```bash
git init
```

**Step 7:** Regenerate the module registries:

```bash
cd ../../  # Back to root
bun run forge modules gen-registry
```

</section>

<section id="packagejson-configuration">
## Package.json Configuration

The `package.json` file is crucial for your module's configuration. Here's a complete example with all available fields:

```json
{
  "name": "@lifeforge/lifeforge--idea-box",
  "displayName": "Idea Box",
  "version": "0.0.2",
  "author": "Melvin Chia <melvinchia623600@gmail.com>",
  "description": "Capture them before the inspiration flies away!",
  "repository": {
    "type": "git",
    "url": "https://github.com/lifeforge-app/lifeforge-module-ideaBox.git"
  },
  "scripts": {
    "types": "cd client && bun tsc"
  },
  "dependencies": {
    "@iconify/react": "^6.0.2",
    "@tanstack/react-query": "^5.90.11",
    "@uidotdev/usehooks": "^2.4.1",
    "clsx": "^2.1.1",
    "dayjs": "^1.11.18",
    "lifeforge-ui": "workspace:*",
    "react": "^19.2.0",
    "react-i18next": "^15.1.1",
    "react-toastify": "^11.0.5",
    "shared": "workspace:*",
    "zod": "^4.1.12"
  },
  "exports": {
    "./server": "./server/index.ts",
    "./manifest": {
      "types": "./manifest.d.ts",
      "default": "./manifest.ts"
    },
    "./server/schema": "./server/schema.ts"
  },
  "lifeforge": {
    "icon": "tabler:bulb",
    "category": "Productivity",
    "APIKeyAccess": {
      "openai": {
        "usage": "AI-powered suggestions",
        "required": false
      }
    }
  }
}
```

### Required Fields

| Field | Description |
|-------|-------------|
| `name` | Full package name: `@lifeforge/<author>--<module-name>` |
| `displayName` | Human-readable name shown in the UI |
| `version` | Semantic version (auto-bumped on publish) |
| `author` | Author name and email |
| `description` | Short description of the module |

### LifeForge-Specific Fields

The `lifeforge` object contains module-specific configuration:

| Field | Type | Description |
|-------|------|-------------|
| `icon` | `string` | Iconify icon identifier (e.g., `tabler:bulb`) |
| `category` | `string` | Sidebar category for grouping |
| `APIKeyAccess` | `object` | Optional API keys the module uses |

### Exports Configuration

The `exports` field defines subpath exports for your module:

```json
{
  "exports": {
    "./manifest": {
      "types": "./manifest.d.ts",
      "default": "./manifest.ts"
    },
    "./server": "./server/index.ts",
    "./server/schema": "./server/schema.ts"
  }
}
```

- `./manifest` – **Required**. The client-side manifest configuration
- `./server` – **Optional**. Server-side routes (only if your module has backend)
- `./server/schema` – **Optional**. Database schema (only if your module has collections)

</section>

<section id="client-manifest">
## Client Manifest

The `manifest.ts` file at the root of your module directory defines the client-side configuration:

```typescript
import { lazy } from 'react'
import type { ModuleConfig } from 'shared'

export default {
  routes: {
    '/': lazy(() => import('@/pages/Home')),
    '/:id': lazy(() => import('@/pages/Detail')),
    '/:id/edit': lazy(() => import('@/pages/Edit'))
  },
  provider: lazy(() => import('./client/providers/MyProvider')),
  subsection: [
    { label: 'Archives', icon: 'tabler:archive', path: '/my-module/archives' }
  ],
  hidden: false,
  disabled: false,
  clearQueryOnUnmount: true
} satisfies ModuleConfig
```

### ModuleConfig Interface

```typescript
interface ModuleConfig {
  // Define the routes for the module
  // Key is the path pattern, value is a lazy-loaded React component
  routes: Record<
    string,
    | React.LazyExoticComponent<React.ComponentType<any>>
    | (() => React.ReactElement)
  >
  
  // Optional wrapper component for all routes in this module
  // Useful for context providers, layout wrappers, etc.
  provider?:
    | React.LazyExoticComponent<React.ComponentType<any>>
    | (() => React.ReactElement)
  
  // Sidebar sub-items under the module
  // Path should be absolute (e.g., '/my-module/subsection')
  subsection?: {
    label: string    // Display text
    icon: string     // Iconify icon
    path: string     // Absolute path
  }[]
  
  // Hide from sidebar (still accessible via direct URL)
  hidden?: boolean
  
  // Completely disable the module
  // Can be a boolean or async function for dynamic checking
  disabled?: boolean | (() => Promise<boolean>)
  
  // Clear React Query cache when navigating away
  clearQueryOnUnmount?: boolean
}
```

### Route Patterns

Routes are relative to your module's base path. For a module named `my-module`:

| Route Pattern | Full URL |
|---------------|----------|
| `'/'` | `/my-module` |
| `'/:id'` | `/my-module/abc123` |
| `'/:id/*'` | `/my-module/abc123/anything` |
| `'/settings'` | `/my-module/settings` |

### Using Providers

Providers wrap all routes in your module, perfect for context providers:

```typescript
// client/providers/IdeaBoxProvider.tsx
import { createContext, useContext } from 'react'

const IdeaBoxContext = createContext<IdeaBoxContextType | null>(null)

export default function IdeaBoxProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState(...)
  
  return (
    <IdeaBoxContext.Provider value={{ state, setState }}>
      {children}
    </IdeaBoxContext.Provider>
  )
}

export const useIdeaBox = () => useContext(IdeaBoxContext)
```

</section>

<section id="server-integration">
## Server Integration

LifeForge provides powerful utilities for building type-safe APIs: `forgeController` and `forgeRouter`. Your module's server entry point (`server/index.ts`) should export a router that aggregates all your route handlers.

### Quick Example

```typescript
// server/index.ts
import { forgeRouter } from '@functions/routes'

import containersRouter from './routes/containers'
import itemsRouter from './routes/items'

export default forgeRouter({
  containers: containersRouter,
  items: itemsRouter
})
```

This creates nested routes like `/containers/list` and `/items/create`.

For comprehensive documentation on `forgeController`, `forgeRouter`, input validation, file uploads, existence checks, and the callback context, see the dedicated [Building API](/developer-guide/building-api) guide.

</section>

<section id="database-schema">
## Database Schema

If your module needs database storage, define a schema in `server/schema.ts`:

```typescript
import z from 'zod'

const myModuleSchemas = {
  containers: {
    schema: z.object({
      name: z.string(),
      icon: z.string(),
      color: z.string(),
      pinned: z.boolean()
    }),
    raw: {
      name: 'my_module__containers',
      type: 'base',
      listRule: '@request.auth.id != ""',
      viewRule: '@request.auth.id != ""',
      createRule: '@request.auth.id != ""',
      updateRule: '@request.auth.id != ""',
      deleteRule: '@request.auth.id != ""',
      fields: [
        {
          name: 'id',
          type: 'text',
          primaryKey: true,
          required: true,
          autogeneratePattern: '[a-z0-9]{15}'
        },
        {
          name: 'name',
          type: 'text',
          required: true
        },
        {
          name: 'icon',
          type: 'text',
          required: true
        },
        {
          name: 'color',
          type: 'text',
          required: true
        },
        {
          name: 'pinned',
          type: 'bool',
          required: false
        }
      ],
      indexes: [
        'CREATE UNIQUE INDEX `idx_name` ON `my_module__containers` (`name`)'
      ]
    }
  }
}

export default myModuleSchemas
```

### Collection Naming Convention

| Module Type | Collection Name Pattern |
|-------------|-------------------------|
| Official | `module_name__collection` |
| Third-party | `username___module_name__collection` |

**Examples:**
- `idea_box__containers` (official)
- `melvinchia3636___invoice__entries` (third-party)

### Schema Structure

Each collection in your schema has two parts:

**`schema`** – A Zod schema for TypeScript type inference:
```typescript
schema: z.object({
  name: z.string(),
  count: z.number(),
  active: z.boolean()
})
```

**`raw`** – PocketBase collection configuration:
```typescript
raw: {
  name: 'collection_name',
  type: 'base',  // or 'view'
  listRule: '@request.auth.id != ""',
  // ... access rules ...
  fields: [
    // Field definitions
  ],
  indexes: [
    // SQL index definitions
  ]
}
```

### View Collections

For computed/aggregated data, use view collections:

```typescript
stats_aggregated: {
  schema: z.object({
    total: z.number(),
    category: z.string()
  }),
  raw: {
    name: 'my_module__stats_aggregated',
    type: 'view',
    listRule: '@request.auth.id != ""',
    viewRule: '@request.auth.id != ""',
    createRule: null,  // Views are read-only
    updateRule: null,
    deleteRule: null,
    viewQuery: `
      SELECT 
        id,
        category,
        COUNT(*) as total
      FROM my_module__items
      GROUP BY category
    `
  }
}
```

### Managing Your Schema

The recommended workflow for managing your module's database schema:

**1. Design in PocketBase Dashboard**

Always configure your collections through the PocketBase admin UI. This ensures:
- Proper field type configuration
- Valid access rules
- Correct relation setup
- No syntax errors in the raw collection config

**2. Pull to Code**

After making changes in the dashboard, pull the schema into your codebase:

```bash
bun run forge db pull <module-name>
```

This generates/updates your `server/schema.ts` file with the correct structure.

**3. Commit to Version Control**

Commit your updated schema file so it's tracked and can be deployed with your module.

### When is <code className="text-xl!">db push</code> Used?

The `db push` command is automatically used during **module installation and updates** to apply the schema to the user's PocketBase instance:

```bash
bun run forge db push <module-name>
```

<Alert className="mt-6" type="caution">
  **Do not manually edit `schema.ts` files.** Always make schema changes through the PocketBase dashboard, then pull. Manual edits can cause:
  - Discrepancies between the Zod schema and PocketBase raw config
  - Invalid collection configurations
  - Deployment failures
</Alert>

</section>

<section id="categorizing-modules">
## Categorizing Modules

Each module can be assigned to a category using the `category` field in `package.json`:

```json
{
  "lifeforge": {
    "category": "Productivity"
  }
}
```

### Custom Category Order

Create `apps/cat.config.json` to define category order:

```json
[
  "Productivity",
  "Finance",
  "Creativity",
  "Entertainment"
]
```

### Special Categories

| Category | Behavior |
|----------|----------|
| `<START>` | Positioned at the top of sidebar |
| `<END>` | Positioned at the bottom of sidebar |
| `Miscellaneous` | Default if no category specified |
| `Settings` | System settings (fixed position) |
| `SSO` | Single sign-on modules (fixed position) |

</section>

<section id="managing-dependencies">
## Managing Dependencies

Each module has its own `package.json` and manages its own dependencies independently.

### Common Dependencies

For your reference, most modules will need the following dependencies:

| Package | Purpose |
|---------|---------|
| `lifeforge-ui` | UI component library (workspace) |
| `shared` | Shared types and utilities (workspace) |
| `@tanstack/react-query` | Data fetching and caching |
| `react-i18next` | Internationalization |
| `zod` | Schema validation |
| `@iconify/react` | Icon rendering |
| `dayjs` | Date manipulation |
| `clsx` | Conditional classNames |

### Installing Dependencies

Always install from within the module directory:

```bash
cd apps/myusername--my-module
bun add some-package
```

<Alert className="mt-6" type="warning">
If you run `bun add` from the root directory, dependencies may be installed at the root level instead of the module level, causing potential issues.
</Alert>

<Alert className="mt-6" type="caution">
  **Watch out for version-sensitive dependencies!** If your module uses third-party packages that share providers or contexts with the main LifeForge client (e.g., `react-query`, `react-i18next`, or UI libraries with context providers), you **must** ensure version consistency. Mismatched versions can cause:
  - Multiple provider instances
  - Broken context sharing
  - Cryptic runtime errors
  
  Always check the versions used in the main client before adding such dependencies to your module.
</Alert>

</section>

<section id="version-control">
## Version Control

Each module **must** maintain its own independent Git repository within the `apps/` directory. This is crucial for keeping the main LifeForge codebase clean and module-free.

<Alert className="mt-6" type="caution">
  **Always initialize Git in your module directory!** If a module doesn't have Git initialized, its files will be tracked alongside the main LifeForge repository. This pollutes the main codebase with module-specific code, making it difficult to:
  - Separate module changes from core changes
  - Publish modules independently
  - Maintain a clean main repository
</Alert>

### Why Separate Git Repositories?

- **Independent version history** – Each module has its own commits and tags
- **Separate release cycles** – Modules can be updated independently
- **Clean main codebase** – LifeForge core stays free of module code
- **Easy collaboration** – Other developers can clone just the module
- **Clean module publishing** – Only module files are published to the registry

### Initializing Git

When creating a module manually, **always** initialize Git:

```bash
cd apps/myusername--my-module
git init
git add .
git commit -m "Initial commit"
```

<Alert className="mt-6" type="note">
  When you install a module via the CLI (`bun run forge modules install`), a Git repository is automatically initialized for you.
</Alert>

</section>

<section id="publishing-modules">
## Publishing Modules

LifeForge allows any developer to publish modules to the registry. You don't need special permissions – just authenticate with your GitHub account.

### Getting Your Auth Token

1. Visit the [LifeForge Module Registry](https://registry.lifeforge.dev)
2. Log in with your GitHub account
3. Obtain your authentication token from the registry website
4. Configure npm/bun with your token

### Publishing Your Module

Once authenticated, publish your module using the CLI:

```bash
bun run forge modules publish <author>--<module-name>
```

### Pre-Publish Checklist

Before publishing, ensure:

1. ✅ All required files exist (manifest.ts, package.json, etc.)
2. ✅ `package.json` has valid `name`, `displayName`, `version`, `author`, `description`
3. ✅ `lifeforge` config has `icon` and `category`
4. ✅ `exports` are correctly configured
5. ✅ All dependencies are properly declared
6. ✅ Localization files exist for all supported languages

### Publishing Process

The CLI will:

1. Validate module structure
2. Validate author permissions (you can only publish your own modules)
3. Bump the version number automatically
4. Publish to the registry

```bash
$ bun run forge modules publish myusername--my-module
  Version: 0.0.1 → 0.0.2
  Published myusername--my-module v0.0.2
```

<Alert className="mt-6" type="note">
  #### Ownership-based access
  
  Only the module author (as identified by the `<author>` prefix in the module name) can publish or unpublish their own packages. You cannot modify modules owned by other users.
</Alert>

</section>

<section id="cli-reference">
## CLI Reference

All module-related commands are under `bun run forge modules`:

| Command | Aliases | Description |
|---------|---------|-------------|
| `list` | `ls` | List all installed modules |
| `install <modules...>` | `i`, `add` | Install modules from registry |
| `uninstall <modules...>` | `un`, `rm`, `remove` | Remove modules |
| `upgrade [module]` | `up`, `u` | Update to latest version |
| `create [name]` | `new` | Create new module (WIP) |
| `publish <module>` | – | Publish to registry |
| `compare [module]` | – | Compare local vs registry |
| `gen-registry` | – | Regenerate route/schema files |

### Examples

```bash
# Install a module
bun run forge modules install lifeforge--calendar

# Install multiple modules
bun run forge modules i lifeforge--calendar lifeforge--todo-list

# Uninstall
bun run forge modules rm lifeforge--calendar

# Check for updates
bun run forge modules up

# Regenerate registries after manual changes
bun run forge modules gen-registry
```

</section>

<section id="best-practices">
## Best Practices

### Code Organization

- Keep components in `client/components/`
- Keep pages in `client/pages/`
- Use providers for shared state
- Separate route handlers into individual files in `server/routes/`

### UI Components

Always utilize components from `lifeforge-ui` whenever applicable. This ensures:
- Consistent styling across the entire LifeForge ecosystem
- Built-in dark mode and theme support
- Automatic localization integration
- No need to reinvent common UI patterns

Refer to the [lifeforge-ui documentation](https://ui.lifeforge.dev) for available components.

### Naming Conventions

- Module name: `<username>--<kebab-case-name>`
- Collection names: `username___module_name__collection_name`
- Route handlers: Descriptive verb names (`list`, `create`, `update`, `remove`)

### Localization

Always provide translations for all supported languages. Use the localization system for all user-facing strings.

### Testing

Test your module thoroughly before publishing:
- Test all frontend pages and components
- Test all backend routes and handlers
- Test localization in all languages
- Test database migrations

</section>

<section id="getting-help">
## Getting Help

If you run into issues or have questions:

- **Bug Reports:** [GitHub Issues](https://github.com/LifeForge-app/lifeforge/issues)
- **Questions:** [GitHub Discussions](https://github.com/LifeForge-app/lifeforge/discussions)
- **UI Components:** Check the [UI Library Documentation](/developer-guide/ui-library)
- **API Building:** See [Building APIs](/developer-guide/building-api)
- **Localization:** Read [Localization Guide](/developer-guide/localization)

</section>
