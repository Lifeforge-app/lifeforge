import { Icon } from '@iconify/react'

import CustomLink from '../../components/CustomLink'
import { Alert } from "lifeforge-ui"

###### Modules

# With Absolute Modularity in Mind

LifeForge is your canvas, and modules are the vibrant colors that bring your creations to life. With LifeForge's modular architecture and your creativity, the possibilities are endless. Being a developer means you can craft your own modules to extend LifeForge's capabilities. Whether you're looking to add new features, integrate with other tools, or customize the user experience, LifeForge's modular design makes it easy to do so.

---

<section id="module-structure">
## Module Structure

All modules in LifeForge are located in the `apps/` directory at the root of the repository. Each module is contained within its own subdirectory, following a consistent structure to ensure ease of development and maintenance.

### Directory Overview

```plaintext
apps/<author>--<module-name>/
├── package.json         # Module metadata, dependencies & peer deps
├── .gitignore           # Git ignore rules
├── .git/                # Independent Git repository (dev mode only)
├── client/              # Frontend code (React + Vite Federation)
│   ├── manifest.ts      # Module configuration & routes (REQUIRED)
│   ├── vite.config.ts   # Vite + Federation config
│   ├── index.html       # Entry HTML
│   ├── tsconfig.json    # Client TypeScript config
│   ├── src/
│   │   ├── pages/       # Route page components
│   │   ├── components/  # Reusable UI components
│   │   ├── widgets/     # Dashboard widgets (optional)
│   │   ├── providers/   # Context providers (optional)
│   │   ├── hooks/       # Custom hooks (optional)
│   │   ├── stores/      # State management (optional)
│   │   └── index.tsx    # Client entry point
│   ├── dist/            # Built bundle (normal mode)
│   └── dist-docker/     # Built bundle (Docker mode)
├── server/              # Backend code (Express + Forge)
│   ├── index.ts         # Route exports via forgeRouter (REQUIRED if has API)
│   ├── forge.ts         # Forge controller factory
│   ├── schema.ts        # Database schema (optional)
│   ├── routes/          # Route handler files
│   │   └── *.ts
│   ├── utils/           # Server utilities (optional)
│   └── dist/            # Built server bundle
└── locales/             # Translations
    ├── en.json
    ├── ms.json
    ├── zh-CN.json
    └── zh-TW.json
```

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:typescript" /><code className="text-xl!">client/manifest.ts</code></div>

This file is the core configuration for your module. It defines routes, navigation, widgets, and behavior. Located inside the `client/` directory, it is exposed via Vite Module Federation.

<CustomLink text="Learn More" to="#client-manifest" />

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:typescript" /><code className="text-xl!">client/vite.config.ts</code></div>

The Vite configuration for building the module as a federated remote. It handles:
- Module Federation setup with shared dependencies
- Path aliases for clean imports
- Dual build modes (normal and Docker)

<CustomLink text="Learn More" to="#module-federation" />

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:folder-client" /><code className="text-xl!">client/</code></div>

This directory contains the frontend code for the module. It is built using React and Tailwind CSS, the same technologies used in the main LifeForge client codebase. A UI library called `lifeforge-ui` is provided in the `packages/` directory to maintain a consistent design language.

The client's `tsconfig.json` provides helpful path aliases:

```json
{
  "compilerOptions": {
    "paths": {
      "@": ["./src/index"],
      "@/*": ["./src/*"],
      "@server/*": ["../server/*"]
    }
  }
}
```

<CustomLink text="Explore UI Library" to="https://ui.lifeforge.dev" />

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:folder-server" /><code className="text-xl!">server/</code></div>

This directory contains the backend code for the module. It is built using ExpressJS with the powerful **Forge Controller** system for type-safe API construction with automatic validation, error handling, and response formatting.

**Key files:**
- `forge.ts` – Creates the Forge controller factory with your schema
- `index.ts` – Exports routes using `forgeRouter`
- `schema.ts` – Defines Zod schemas for your collections
- `routes/*.ts` – Individual route handler files

<CustomLink text="Learn More" to="#server-integration" />

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:folder-i18n" /><code className="text-xl!">locales/</code></div>

This directory contains the localization files for the module. LifeForge features a **dynamic localization engine** powered by i18next with:

- **Dynamic Loading** – Translations are fetched on-demand via HTTP backend
- **Namespace Architecture** – Your module uses `modules.<moduleName>` namespace
- **Missing Key Reporting** – Automatic server-side logging for debugging

Create a JSON file for each language you want to support. Your module's translations will be automatically loaded when users have the corresponding language pack installed.

<Alert className="mt-6" type="tip">
  Provide translations for at least the languages bundled with LifeForge (English), but you can add support for any language.
</Alert>

<CustomLink text="Learn More" to="/developer-guide/localization" />

### <div className="flex items-center gap-3"><Icon icon="material-icon-theme:nodejs" /><code className="text-xl!">package.json</code></div>

This file contains the module's metadata and dependencies. LifeForge's monorepo is managed using **bun**, which supports workspaces natively.

<CustomLink text="Learn More" to="#packagejson-configuration" />
 
</section>

<section id="module-naming">
## Module Naming

Modules follow a strict naming convention that determines their identity and scope.

### Naming Patterns

| Type | Format | Example | Scope Key |
|------|--------|---------|-----------|
| Official | `lifeforge--<name>` | `lifeforge--calendar` | `calendar` |
| Community | `<author>--<name>` | `melvinchia3636--invoice-maker` | `melvinchia3636$invoiceMaker` |

### Scope Key Generation

The scope key is used internally for routing and namespacing:

1. **Official modules** (`lifeforge--*`): Use camelCase of the name after `--`
   - `lifeforge--todo-list` → `todoList`
2. **Community modules**: Combine author with camelCase name using `$`
   - `melvinchia3636--invoice-maker` → `melvinchia3636$invoiceMaker`

### Full Package Name

All modules are published under the `@lifeforge` npm scope:

```
@lifeforge/<author>--<module-name>
```

Examples:
- `@lifeforge/lifeforge--wallet`
- `@lifeforge/melvinchia3636--invoice-maker`

</section>

<section id="creating-modules">
## Creating Modules

<Alert className="mt-6" type="warning">
  The `ForgeCLI` module creation wizard is currently a **work in progress**. For now, create modules manually by following the structure outlined in this guide.
</Alert>

### Manual Module Creation

Follow these steps to create a new module:

**Step 1:** Create a new directory in `apps/`:

```bash
mkdir apps/myusername--my-module
cd apps/myusername--my-module
```

**Step 2:** Create the `package.json` file:

```json
{
  "name": "@lifeforge/myusername--my-module",
  "displayName": "My Module",
  "version": "0.0.1",
  "author": "Your Name <your@email.com>",
  "description": "Description of what your module does",
  "scripts": {
    "types": "cd client && bun tsc",
    "build:client": "cd client && bun run vite build",
    "build:server": "bun build ./server/index.ts --outdir ./server/dist --target bun --external @lifeforge/server-utils --external zod"
  },
  "dependencies": {},
  "devDependencies": {},
  "lifeforge": {
    "icon": "tabler:cube",
    "category": "Utilities"
  },
  "peerDependencies": {
    "@lifeforge/server-utils": "workspace:*",
    "lifeforge-ui": "workspace:*",
    "shared": "workspace:*"
  }
}
```

**Step 3:** Create the directory structure:

```bash
mkdir -p client/src/{pages,components} server/routes locales
```

**Step 4:** Create essential files:
- `client/manifest.ts` – Module configuration
- `client/src/pages/Home.tsx` – Initial page
- `client/vite.config.ts` – Vite configuration
- `client/index.html` – Entry HTML
- `server/index.ts` – Route exports (if needed)
- `locales/en.json` – English translations

**Step 5:** Install dependencies from root:

```bash
cd ../../  # Back to monorepo root
bun install
```

**Step 6:** Initialize Git (for development):

```bash
cd apps/myusername--my-module
git init
git add .
git commit -m "Initial commit"
```

</section>

<section id="packagejson-configuration">
## Package.json Configuration

The `package.json` file is crucial for your module's configuration.

### Complete Example

```json
{
  "name": "@lifeforge/lifeforge--wallet",
  "displayName": "Wallet",
  "version": "0.0.5",
  "author": "Melvin Chia <melvinchia623600@gmail.com>",
  "description": "Become your own financial superhero.",
  "repository": {
    "type": "git",
    "url": "https://github.com/lifeforge-app/lifeforge-module-wallet.git"
  },
  "scripts": {
    "types": "cd client && bun tsc",
    "build:client": "cd client && bun run vite build",
    "build:server": "bun build ./server/index.ts --outdir ./server/dist --target bun --external @lifeforge/server-utils --external zod"
  },
  "dependencies": {
    "chart.js": "^4.5.0",
    "recharts": "^2.15.0",
    "zustand": "^5.0.8"
  },
  "devDependencies": {},
  "lifeforge": {
    "icon": "tabler:currency-dollar",
    "category": "Finance",
    "APIKeyAccess": {
      "openai": {
        "usage": "AI-powered analysis",
        "required": false
      }
    }
  },
  "peerDependencies": {
    "@lifeforge/server-utils": "workspace:*",
    "lifeforge-ui": "workspace:*",
    "shared": "workspace:*"
  }
}
```

### Required Fields

| Field | Description |
|-------|-------------|
| `name` | Full package name: `@lifeforge/<author>--<module-name>` |
| `displayName` | Human-readable name shown in the UI |
| `version` | Semantic version (auto-bumped on publish) |
| `author` | Author name and email |
| `description` | Short description of the module |

### LifeForge-Specific Fields

The `lifeforge` object contains module-specific configuration:

| Field | Type | Description |
|-------|------|-------------|
| `icon` | `string` | Iconify icon identifier (e.g., `tabler:bulb`) |
| `category` | `string` | Sidebar category for grouping |
| `APIKeyAccess` | `object` | Optional API keys the module uses |

### Required Peer Dependencies

All modules **must** declare these peer dependencies:

```json
{
  "peerDependencies": {
    "@lifeforge/server-utils": "workspace:*",
    "lifeforge-ui": "workspace:*",
    "shared": "workspace:*"
  }
}
```

### Scripts

Standard scripts for module development:

| Script | Purpose |
|--------|---------|
| `types` | Type-check the client code |
| `build:client` | Build client federation bundle |
| `build:server` | Build server bundle for production |

</section>

<section id="client-manifest">
## Client Manifest

The `client/manifest.ts` file defines the client-side configuration for your module:

```typescript
import { lazy } from 'react'
import type { ModuleConfig } from 'shared'

export default {
  // Route definitions (REQUIRED)
  routes: {
    '/': lazy(() => import('@/pages/Dashboard')),
    '/transactions': lazy(() => import('@/pages/Transactions')),
    '/:id': lazy(() => import('@/pages/Detail')),
    '/:id/edit': lazy(() => import('@/pages/Edit'))
  },
  
  // Sidebar navigation items
  subsection: [
    { label: 'Dashboard', icon: 'tabler:dashboard', path: '' },
    { label: 'Transactions', icon: 'tabler:arrows-exchange', path: 'transactions' }
  ],
  
  // Optional context provider that will be accessible globally
  provider: lazy(() => import('@/providers/ModuleProvider')),
  
  // Dashboard widgets
  widgets: [
    () => import('@/widgets/AssetsBalance'),
    () => import('@/widgets/MonthlySpending')
  ],
  
  // Module visibility
  hidden: false,
  disabled: false,
  clearQueryOnUnmount: true
} satisfies ModuleConfig
```

### ModuleConfig Interface

```typescript
interface ModuleConfig {
  // Route definitions (path -> lazy component)
  routes: Record<
    string,
    | React.LazyExoticComponent<React.ComponentType<any>>
    | (() => React.ReactElement)
  >
  
  // Optional wrapper component for all routes
  provider?:
    | React.LazyExoticComponent<React.ComponentType<any>>
    | (() => React.ReactElement)
  
  // Sidebar sub-items under the module
  // Path is RELATIVE to module base (empty string = root)
  subsection?: {
    label: string    // Display text (i18n key supported)
    icon: string     // Iconify icon
    path: string     // Relative path (e.g., 'transactions', not '/transactions')
  }[]
  
  // Dashboard widget loaders
  widgets?: (() => Promise<{
    default: React.ComponentType<any>
    config: WidgetConfig
  }>)[]
  
  // Hide from sidebar (still accessible via direct URL)
  hidden?: boolean
  
  // Completely disable the module
  disabled?: boolean | (() => Promise<boolean>)
  
  // Clear React Query cache when navigating away
  clearQueryOnUnmount?: boolean
}
```

### Route Patterns

Routes are relative to your module's base path. For a module named `my-module`:

| Route Pattern | Full URL |
|---------------|----------|
| `'/'` | `/my-module` |
| `'/:id'` | `/my-module/abc123` |
| `'/:id/*'` | `/my-module/abc123/anything` |
| `'/settings'` | `/my-module/settings` |

### Subsection Paths

Subsection paths are **relative** to the module, not absolute:

```typescript
subsection: [
  { label: 'Home', icon: 'tabler:home', path: '' },           // /my-module
  { label: 'Archive', icon: 'tabler:archive', path: 'archive' } // /my-module/archive
]
```

### Using Providers

Providers wrap all routes in your module, perfect for context providers:

```typescript
// client/src/providers/ModuleProvider.tsx
import { createContext, useContext, useState } from 'react'

const ModuleContext = createContext<ModuleContextType | null>(null)

export default function ModuleProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState(...)
  
  return (
    <ModuleContext.Provider value={{ state, setState }}>
      {children}
    </ModuleContext.Provider>
  )
}

export const useModule = () => useContext(ModuleContext)
```

</section>

<section id="dashboard-widgets">
## Dashboard Widgets

Modules can contribute widgets to the LifeForge dashboard. Widgets are grid-based components that users can add, resize, and rearrange.

### Widget Definition

Each widget exports a component and a configuration object:

```typescript
// client/src/widgets/AssetsBalance/index.tsx
import type { WidgetConfig } from 'shared'

function AssetsBalanceWidget() {
  // Widget implementation
  return (
    <div className="p-4">
      <h3>Assets Balance</h3>
      {/* Widget content */}
    </div>
  )
}

export const config: WidgetConfig = {
  id: 'assets-balance',    // Unique widget ID
  icon: 'tabler:wallet',   // Dashboard icon
  minW: 2,                 // Minimum grid width
  minH: 2,                 // Minimum grid height
  maxW: 4,                 // Maximum grid width (optional)
  maxH: 3                  // Maximum grid height (optional)
}

export default AssetsBalanceWidget
```

### WidgetConfig Interface

```typescript
interface WidgetConfig {
  namespace?: string  // Auto-filled from module
  id: string          // Unique widget ID within module
  icon: string        // Iconify icon name
  minW?: number       // Minimum grid columns (default: 1)
  minH?: number       // Minimum grid rows (default: 1)
  maxW?: number       // Maximum grid columns
  maxH?: number       // Maximum grid rows
}
```

### Registering Widgets

Add widgets to your manifest:

```typescript
// client/manifest.ts
export default {
  routes: { ... },
  widgets: [
    () => import('@/widgets/AssetsBalance'),
    () => import('@/widgets/MonthlySpending'),
    () => import('@/widgets/RecentTransactions')
  ]
} satisfies ModuleConfig
```
</section>

<section id="server-integration">
## Server Integration

LifeForge uses the **Forge Controller** system from `@lifeforge/server-utils` for type-safe APIs.

### Server Structure

```plaintext
server/
├── index.ts       # Main router export
├── forge.ts       # Forge controller factory
├── schema.ts      # Zod schemas for collections
└── routes/
    └── *.ts       # Route handler files
```

### Quick Example

```typescript
// server/forge.ts
import { createForge } from '@lifeforge/server-utils'
import schema from './schema'
export default createForge(schema)

// server/routes/items.ts
import forge from '../forge'
export const list = forge.query().input({}).callback(({ pb }) =>
  pb.getFullList.collection('items').execute()
)

// server/index.ts
import { forgeRouter } from '@lifeforge/server-utils'
import * as itemsRouter from './routes/items'
export default forgeRouter({ items: itemsRouter })
```

For complete API documentation, see [Building API](/developer-guide/building-api).

</section>

<section id="database-schema">
## Database Schema

If your module needs database storage, define schemas in `server/schema.ts`:

```typescript
import { cleanSchemas } from '@lifeforge/server-utils'
import z from 'zod'

const schemas = {
  items: z.object({
    name: z.string(),
    description: z.string().optional(),
    category: z.string(),
    pinned: z.boolean()
  }),
  
  categories: z.object({
    name: z.string(),
    icon: z.string(),
    color: z.string()
  })
}

export default cleanSchemas(schemas)
```

### Collection Naming Convention

| Module Type | Collection Name Pattern |
|-------------|-------------------------|
| Official | `module_name__collection` |
| Community | `username___module_name__collection` |

**Examples:**
- `idea_box__containers` (official)
- `melvinchia3636___invoice__entries` (community)

### Schema Workflow

1. **Design in PocketBase Dashboard** – Configure collections through the admin UI
2. **Pull to Code** – `bun forge db pull <module-name>`
3. **Commit** – Track your schema in version control
4. **Push (on install)** – `bun forge db push <module-name>` applies schema

<Alert className="mt-6" type="caution">
  **Do not manually edit `schema.ts` files.** Make changes through PocketBase, then pull.
</Alert>

</section>

<section id="module-federation">
## Module Federation

LifeForge uses **Vite Module Federation** to enable dynamic loading of modules at runtime.

### How It Works

1. **Host Application** – The main LifeForge client acts as the federation host
2. **Remote Modules** – Each module is built as a federated remote
3. **Shared Dependencies** – Core libraries are shared to avoid duplication

### Module Vite Configuration

```typescript
// client/vite.config.ts
import federation from '@originjs/vite-plugin-federation'
// ... standard imports (react, tailwindcss, dotenv, path, vite)

const moduleName = pkg.name.replace('@lifeforge/', '')
const apiHost = process.env.DOCKER_BUILD === 'true' ? '/api' : process.env.VITE_API_HOST

export default defineConfig({
  base: `${apiHost}/modules/${moduleName}/`,
  plugins: [
    react(),
    tailwindcss(),
    federation({
      name: moduleName,
      filename: 'remoteEntry.js',
      exposes: {
        './Manifest': './manifest.ts'
      },
      shared: {
        react: { generate: false },
        'react-dom': { generate: false },
        shared: { generate: false },
        'lifeforge-ui': { generate: false },
        'react-i18next': { generate: false },
        i18next: { generate: false },
        '@tanstack/react-query': { generate: false }
      }
    })
  ],
  // ... resolve aliases (@, @/*, @server/*)
  build: {
    outDir: process.env.DOCKER_BUILD ? 'dist-docker' : 'dist',
    target: 'esnext',
    minify: true,
    modulePreload: false
  }
})
```

### Dual Build Modes

Modules are built in **two modes**:

| Mode | Output Dir | Base URL | Use Case |
|------|------------|----------|----------|
| Normal | `dist/` | `http://localhost:3636` | Local development |
| Docker | `dist-docker/` | `/api` | Docker deployment |

Both are built automatically during module installation.

### Shared Dependencies

These packages are provided by the host and **must not** be bundled:

| Package | Purpose |
|---------|---------|
| `react` | Core React library (singleton) |
| `react-dom` | React DOM bindings (singleton) |
| `shared` | LifeForge shared utilities |
| `lifeforge-ui` | UI component library |
| `@tanstack/react-query` | Data fetching |
| `i18next` / `react-i18next` | Internationalization |

<Alert className="mt-6" type="important">
  **React must be a singleton!** Libraries using React hooks must share the same React instance. If you see errors like `ReactSharedInternals.H is null`, check your federation shared config.
</Alert>

### Libraries with React Hooks

Libraries like `recharts`, `react-beautiful-dnd`, etc., that use React hooks internally need special handling:

<Alert className="mt-6" type="caution">
  **Do NOT add these libraries to federation `shared` config!** Let them bundle normally – the federation plugin rewrites React imports to use the shared instance.
</Alert>

Install hook-using libraries in your module:

```bash
cd apps/myusername--my-module
bun add recharts@^2.15.0
```

<Alert className="mt-6" type="warning">
#### Known Issues

- `recharts@3.x` introduced breaking changes with ESM module loading. Stick to `recharts@^2.15.0` for best compatibility.
</Alert>

</section>

<section id="building-modules">
## Building Modules

### Using the CLI

Build your module using the Forge CLI:

```bash
# Build normal dist
bun forge modules build <module-name>

# Build Docker dist
bun forge modules build <module-name> --docker

# Build all modules
bun forge modules build
```

### What Gets Built

| Command | Client Output | Server Output |
|---------|---------------|---------------|
| `build` | `client/dist/` | `server/dist/` |
| `build --docker` | `client/dist-docker/` | `server/dist/` |

### Build Output Structure

```plaintext
client/dist/
├── remoteEntry.js    # Federation entry point
├── assets/
│   ├── *.js          # Code chunks
│   └── *.css         # Styles
└── index.html        # Fallback

server/dist/
└── index.js          # Bundled server code
```

<Alert className="mt-6" type="tip">
  During development, the server runs source TypeScript directly (Bun executes TS natively). Builds are only needed for production deployment.
</Alert>

</section>

<section id="installation-modes">
## Installation Modes

When installing modules, you can choose between **production** and **development** modes.

### Production Mode (Default)

```bash
bun forge modules install lifeforge--calendar
```

**Behavior:**
- Downloads module from registry
- Builds both `dist/` and `dist-docker/` bundles
- Generates database migrations if schema.ts exists
- **Removes source code** – Only compiled bundles are retained
- No Git repository initialized
- Optimized for deployment

### Development Mode

```bash
bun forge modules install lifeforge--calendar --dev
```

**Behavior:**
- Downloads module from registry
- Builds both `dist/` and `dist-docker/` bundles
- **Preserves source code** – Full source available for development
- **Initializes Git repository** – Ready for version control
- Ideal for contributing or customizing modules

<Alert className="mt-6" type="note">
  Use `--dev` when you want to modify or contribute to a module. Use the default mode for clean production deployments.
</Alert>

</section>

<section id="version-control">
## Version Control

Each module **should** maintain its own independent Git repository within the `apps/` directory.

<Alert className="mt-6" type="note">
  Git repositories are only initialized when installing with the `--dev` flag, or when creating modules manually.
</Alert>

### Why Separate Git Repositories?

- **Independent version history** – Each module has its own commits and tags
- **Separate release cycles** – Modules can be updated independently
- **Clean main codebase** – LifeForge core stays free of module code
- **Easy collaboration** – Other developers can clone just the module
- **Clean publishing** – Only module files are published to the registry

### For Development

When creating or installing modules for development:

```bash
# Manual creation
cd apps/myusername--my-module
git init
git add .
git commit -m "Initial commit"

# Or install with --dev
bun forge modules install lifeforge--calendar --dev
```

### For Production

In production mode, no Git repository is created. The `apps/` directory contains only built artifacts, keeping deployments clean and lightweight.

</section>

<section id="publishing-modules">
## Publishing Modules

LifeForge allows any developer to publish modules to the registry.

### Getting Your Auth Token

1. Visit the [LifeForge Module Registry](https://registry.lifeforge.dev)
2. Log in with your GitHub account
3. Obtain your authentication token
4. Configure npm/bun with your token

### Publishing Your Module

```bash
bun forge modules publish <author>--<module-name>
```

### Pre-Publish Checklist

1. All required files exist (manifest.ts, package.json, etc.)
2. `package.json` has valid `name`, `displayName`, `version`, `author`, `description`
3. `lifeforge` config has `icon` and `category`
4. `peerDependencies` are correctly declared
5. All dependencies are properly declared
6. Localization files exist for supported languages

### Publishing Process

The CLI will:

1. Validate module structure
2. Validate author permissions (you can only publish your own modules)
3. Bump the version number automatically
4. Rename `.gitignore` temporarily (npm excludes it)
5. Publish to the registry
6. Restore `.gitignore`

```bash
$ bun forge modules publish myusername--my-module
  Version: 0.0.1 → 0.0.2
  ✔ Published myusername--my-module v0.0.2
```

<Alert className="mt-6" type="note">
  #### Ownership-based access
  
  Only the module author (identified by the `<author>` prefix) can publish or unpublish their packages.
</Alert>

</section>

<section id="cli-reference">
## CLI Reference

All module-related commands are under `bun forge modules`:

### Commands

| Command | Aliases | Description |
|---------|---------|-------------|
| `list` | `ls` | List all installed modules |
| `install <modules...>` | `i`, `add` | Install modules from registry |
| `uninstall <modules...>` | `un`, `rm`, `remove` | Remove modules |
| `upgrade [module]` | `up`, `u` | Update to latest version |
| `build [module]` | `b` | Build federation bundles |
| `create [name]` | `new` | Create new module (WIP) |
| `publish <module>` | – | Publish to registry |
| `compare [module]` | – | Compare local vs registry |

### Install Options

| Option | Description |
|--------|-------------|
| `--dev` | Preserve source code and initialize Git repository |

### Build Options

| Option | Description |
|--------|-------------|
| `--docker` | Build for Docker deployment (output to `dist-docker/`) |

### Examples

```bash
# List installed modules
bun forge modules list

# Install a module (production mode)
bun forge modules install lifeforge--calendar

# Install for development
bun forge modules install lifeforge--calendar --dev

# Install multiple modules
bun forge modules i lifeforge--calendar lifeforge--todo-list

# Uninstall
bun forge modules rm lifeforge--calendar

# Check for updates
bun forge modules up

# Build a specific module
bun forge modules build lifeforge--calendar

# Build all modules for Docker
bun forge modules build --docker
```

</section>

<section id="categorizing-modules">
## Categorizing Modules

Each module is assigned to a category using the `category` field in `package.json`:

```json
{
  "lifeforge": {
    "category": "Productivity"
  }
}
```

### Default Behavior

By default, categories are sorted **alphabetically** in the sidebar. Special categories have fixed positions:

| Category | Behavior |
|----------|----------|
| `<START>` | Always at the top of sidebar |
| `Miscellaneous` | Default if no category specified |
| `Settings` | Fixed position at bottom |
| `SSO` | Fixed position at bottom |
| `<END>` | Always at the bottom of sidebar |

### Category Management

Category order and translations are managed server-side via the **Module Manager** module (`lifeforge--module-manager`). The UI allows you to:

- **Reorder categories** – Drag and drop to customize sidebar order
- **Add translations** – Provide category names in multiple languages
- **AI translation** – Auto-translate category names using OpenAI

Category configuration is stored in `module_categories.json` on the server with the format:

```typescript
// Record<categoryKey, Record<languageCode, translatedLabel>>
{
  "productivity": {
    "en": "Productivity",
    "zh-CN": "生产力",
    "ms": "Produktiviti"
  },
  "finance": {
    "en": "Finance",
    "zh-CN": "财务",
    "ms": "Kewangan"
  }
}
```

<Alert className="mt-6" type="tip">
  Install the Module Manager module to access the category management UI: `bun forge modules install lifeforge--module-manager`
</Alert>

</section>

<section id="managing-dependencies">
## Managing Dependencies

LifeForge uses **hoisted dependencies** – common packages are installed at the root level and shared across all workspaces.

### How It Works

- **Root `package.json`** – Contains common dependencies shared by all modules (React, Zod, dayjs, etc.)
- **Module `package.json`** – Only contains **module-specific** dependencies not in root
- **Peer dependencies** – Core packages provided by the monorepo infrastructure

### Root-Level Dependencies

These are already available to all modules via the root `package.json`:

| Package | Purpose |
|---------|---------|
| `react`, `react-dom` | Core React |
| `@tanstack/react-query` | Data fetching and caching |
| `react-i18next`, `i18next` | Internationalization |
| `zod` | Schema validation |
| `@iconify/react` | Icon rendering |
| `dayjs` | Date manipulation |
| `clsx` | Conditional classNames |
| `lodash` | Utility functions |
| `react-toastify` | Toast notifications |

### Peer Dependencies

Modules must declare these as peer dependencies (from workspace):

```json
{
  "peerDependencies": {
    "@lifeforge/server-utils": "workspace:*",
    "lifeforge-ui": "workspace:*",
    "shared": "workspace:*"
  }
}
```

### Adding Module-Specific Dependencies

Only add dependencies that are **not** in the root `package.json`:

```bash
cd apps/myusername--my-module
bun add recharts zustand  # Module-specific packages
```

<Alert className="mt-6" type="tip">
  Check the root `package.json` before adding dependencies – if it's already there, you don't need to add it to your module.
</Alert>

</section>

<section id="best-practices">
## Best Practices

### Code Organization

- Keep components in `client/src/components/`
- Keep pages in `client/src/pages/`
- Use providers for shared state
- Separate route handlers into individual files in `server/routes/`
- One component per file

### UI Components

Always use components from `lifeforge-ui` when available:
- Consistent styling across LifeForge
- Built-in dark mode and theme support
- Automatic localization integration

Refer to the [lifeforge-ui documentation](https://ui.lifeforge.dev).

### Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Module name | `<author>--<kebab-case>` | `myuser--invoice-maker` |
| Collection name | `<module>__<collection>` | `wallet__transactions` |
| Route handlers | Verb names | `list`, `create`, `update`, `remove` |
| Components | PascalCase | `TransactionList.tsx` |

### Localization

Always provide translations for all supported languages. Use the localization system for all user-facing strings.

### Testing

Before publishing:
- Test all frontend pages and components
- Test all backend routes
- Test localization in all languages
- Verify database schema migrations

</section>

<section id="getting-help">
## Getting Help

If you run into issues or have questions:

- **Bug Reports:** [GitHub Issues](https://github.com/LifeForge-app/lifeforge/issues)
- **Questions:** [GitHub Discussions](https://github.com/LifeForge-app/lifeforge/discussions)
- **UI Components:** Check the [UI Library Documentation](https://ui.lifeforge.dev)
- **API Building:** See [Building APIs](/developer-guide/building-api)
- **Localization:** Read [Localization Guide](/developer-guide/localization)

</section>
